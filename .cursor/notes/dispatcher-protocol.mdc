---
description: Signal file protocol for FileDispatcher — how external agents interact with the calibration/investigation pipeline via signal.json
---

# Dispatcher Protocol — signal.json

## Overview

The FileDispatcher communicates with external agents (Cursor skill, harness, scripts) via a `signal.json` file. The Go process writes the signal; the external agent reads it, produces an artifact, and writes the artifact to disk. The Go process detects the artifact and continues.

## Fail-fast mechanisms

The protocol is designed to avoid unnecessary timeouts:

1. **`dispatch_id` (monotonic)** — Each signal carries a unique `dispatch_id`. The agent **must** echo it in the artifact wrapper. Artifacts with a mismatched `dispatch_id` are silently ignored as stale. This eliminates race conditions without timing fences.
2. **Responder error propagation** — If the responder encounters an error (e.g. cannot read the prompt), it writes `status: "error"` back to `signal.json` with the same `dispatch_id`. The dispatcher detects this on the next poll and fails immediately instead of waiting for timeout.
3. **Invalid JSON** — If the artifact file exists but contains invalid JSON after two read attempts, the dispatcher fails immediately.

## signal.json schema

```json
{
  "status": "waiting",
  "dispatch_id": 1,
  "case_id": "C1",
  "step": "F0_RECALL",
  "prompt_path": "/abs/path/to/prompt-recall.md",
  "artifact_path": "/abs/path/to/recall-result.json",
  "timestamp": "2026-02-16T12:00:00Z",
  "error": ""
}
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | Current state: `waiting`, `processing`, `done`, `error` |
| `dispatch_id` | int64 | Monotonic ID — agent must echo this in the artifact wrapper |
| `case_id` | string | Ground-truth case ID (e.g. "C1") |
| `step` | string | Pipeline step (e.g. "F0_RECALL", "F1_TRIAGE") |
| `prompt_path` | string | Absolute path to the filled prompt file (markdown) |
| `artifact_path` | string | Absolute path where the agent must write the JSON artifact |
| `timestamp` | string | ISO 8601 timestamp of when the signal was created |
| `error` | string | Error message (only present when `status` is `error`) |

### Status transitions

```
waiting → processing → done
waiting → error (timeout, invalid artifact, or responder-reported error)
```

- **waiting**: Go process has written the signal and is polling for the artifact.
- **processing**: Go process has found and validated the artifact; evaluating.
- **done**: Go process has finished processing; ready for next step.
- **error**: Something went wrong (timeout, invalid JSON, responder error, etc.).

## Artifact wrapper

The artifact file **must** be a JSON object with the `dispatch_id` echoed from the signal and the actual step payload under `data`:

```json
{
  "dispatch_id": 1,
  "data": {
    "match": true,
    "confidence": 0.95,
    "reasoning": "..."
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `dispatch_id` | int64 | Must match the `dispatch_id` from the current `signal.json` |
| `data` | object | The actual step artifact (schema depends on the pipeline step) |

If `dispatch_id` does not match, the dispatcher treats the artifact as stale and continues polling. This means leftover artifacts from previous steps are harmlessly ignored.

## Agent-side contract

When `status` is `waiting`:

1. Read `dispatch_id` and `prompt_path` from signal.json.
2. Open and read the prompt file (markdown with all context).
3. Analyze the failure data provided in the prompt.
4. Produce the appropriate JSON artifact for the pipeline step.
5. **Wrap it**: `{"dispatch_id": <from signal>, "data": <your artifact>}`.
6. Write the wrapped JSON to `artifact_path` from signal.json.
7. (The Go process detects the artifact file automatically — no need to update signal.json.)

### Error reporting

If the agent encounters an error (e.g. cannot read the prompt, internal failure), it should update `signal.json` directly:

```json
{
  "status": "error",
  "dispatch_id": 1,
  "error": "description of what went wrong",
  ...other fields unchanged...
}
```

The dispatcher will detect this and fail fast.

### Watcher loop (pseudocode)

```
while true:
    signal = read("signal.json")
    if signal.status == "waiting":
        prompt = read(signal.prompt_path)
        if error reading prompt:
            signal.status = "error"
            signal.error = "cannot read prompt"
            write("signal.json", signal)
            continue
        artifact = analyze(prompt, signal.step)
        wrapped = {"dispatch_id": signal.dispatch_id, "data": artifact}
        write(signal.artifact_path, wrapped)
    sleep(poll_interval)
```

## Signal file location

The signal.json is written to the artifact directory for the current case:

```
.asterisk/calibrate/{suiteID}/{caseID}/signal.json
```

Or to a custom `SignalDir` if configured.

## Artifact filenames by step

| Step | Artifact filename |
|------|------------------|
| F0 Recall | `recall-result.json` |
| F1 Triage | `triage-result.json` |
| F2 Resolve | `resolve-result.json` |
| F3 Investigate | `artifact.json` |
| F4 Correlate | `correlate-result.json` |
| F5 Review | `review-decision.json` |
| F6 Report | `jira-draft.json` |

## CLI usage

```bash
# Interactive (default) — stdin dispatcher
asterisk calibrate --scenario=ptp-mock --adapter=cursor --dispatch=stdin

# Automated — file dispatcher with signal polling
asterisk calibrate --scenario=ptp-mock --adapter=cursor --dispatch=file
```

## Timeouts

- Default poll interval: 500ms
- Default timeout: 10 minutes
- On timeout: signal.json updated to `status: "error"` with error message

## Debugging

Use `--agent-debug` to enable structured debug logging to stderr. This traces every filesystem operation in the dispatcher (signal writes, artifact polls, dispatch_id matching, MarkDone transitions).

```bash
# Debug mode — traces all dispatcher I/O to stderr
asterisk calibrate --scenario=ptp-mock --adapter=cursor --dispatch=file --agent-debug

# Combine with the mock-calibration-agent's --debug flag for full bidirectional trace
mock-calibration-agent --debug .asterisk/calibrate
```

Debug output includes:
- Signal file writes with status transitions and dispatch_id
- Dispatch_id mismatch rejection (stale artifact detection)
- Responder error detection via signal.json
- Poll counts and artifact discovery timing
- JSON validation results
- MarkDone transitions

## Batch dispatch (multi-subagent mode)

When `--dispatch=batch-file` is used with `--parallel=N`, the Go CLI writes multiple signals simultaneously and coordinates them through a batch manifest. This enables the Cursor skill to spawn parallel Task subagents.

### Batch manifest

**Location**: `.asterisk/calibrate/{suiteID}/batch-manifest.json`

```json
{
  "batch_id": 1,
  "status": "pending",
  "phase": "triage",
  "created_at": "2026-02-17T10:00:00Z",
  "updated_at": "2026-02-17T10:00:00Z",
  "total": 4,
  "briefing_path": ".asterisk/calibrate/1001/briefing.md",
  "signals": [
    {
      "case_id": "C1",
      "signal_path": ".asterisk/calibrate/1001/101/signal.json",
      "status": "pending"
    },
    {
      "case_id": "C2",
      "signal_path": ".asterisk/calibrate/1001/102/signal.json",
      "status": "pending"
    }
  ]
}
```

| Field | Type | Description |
|-------|------|-------------|
| `batch_id` | int64 | Monotonic batch counter within a calibration run |
| `status` | string | Batch lifecycle: `pending`, `in_progress`, `done`, `error` |
| `phase` | string | Pipeline phase: `triage` (F0+F1) or `investigation` (F2-F6) |
| `created_at` | string | ISO 8601 timestamp of batch creation |
| `updated_at` | string | ISO 8601 timestamp of last status change |
| `total` | int | Number of signals in this batch |
| `briefing_path` | string | Path to the shared briefing file for this batch |
| `signals` | array | Per-case signal entries |
| `signals[].case_id` | string | Ground-truth case ID |
| `signals[].signal_path` | string | Path to the case's `signal.json` |
| `signals[].status` | string | Per-signal status: `pending`, `claimed`, `done`, `error` |

### Manifest lifecycle

```
pending → in_progress → done
pending → error (timeout, all signals failed)
```

- **pending**: Go CLI has written all signals and the manifest. Waiting for skill.
- **in_progress**: Skill has read the manifest and is spawning subagents.
- **done**: All signals have artifacts. Go CLI can proceed.
- **error**: Batch-level failure (timeout, unrecoverable errors).

### Briefing file

**Location**: `.asterisk/calibrate/{suiteID}/briefing.md`

A curated markdown file providing shared context for all subagents in a batch:

- **Run context** — scenario name, suite ID, phase, case counts
- **Known symptoms** — from completed triage (category, component, defect hypothesis per case)
- **Cluster assignments** — investigation phase only; cluster key, representative, members
- **Prior RCAs** — from completed investigations
- **Common error patterns** — frequency analysis of error messages

The briefing is regenerated before each batch. It grows as more batches complete.

### Concurrent signal semantics

1. Go CLI writes N signals to per-case dirs (existing protocol — no change per signal).
2. Go CLI writes `batch-manifest.json` listing all N signals.
3. Go CLI writes `briefing.md` with shared context.
4. Skill parent reads manifest, reads briefing, spawns up to K subagents (K <= min(N, 4)).
5. Each subagent reads its signal (existing protocol), reads the briefing, analyzes, writes artifact.
6. Go CLI polls each artifact path independently (existing protocol).
7. When all N artifacts are present, the batch is complete.

### Subagent response contract

Each subagent writes artifacts in the existing `artifactWrapper` format — no schema changes:

```json
{"dispatch_id": 7, "data": { ...step-specific artifact... }}
```

The subagent reads the briefing for shared context but produces the same artifact it would in single-agent mode.

### Budget status (optional)

When `--token-budget` is set, the Go CLI writes a `budget-status.json` alongside the manifest:

```json
{
  "total_budget": 100000,
  "used": 45000,
  "remaining": 55000,
  "percent_used": 45.0
}
```

The skill parent reads this between batches to decide whether to continue spawning subagents.

### Backward compatibility

When `batch-manifest.json` does not exist, the skill falls back to single-signal sequential mode. The Go CLI falls back to sequential dispatch. The protocol is opt-in via `--dispatch=batch-file`.

### CLI usage

```bash
# Batch dispatch with 4 subagents per batch
asterisk calibrate --scenario=ptp-mock --adapter=cursor --dispatch=batch-file --batch-size=4

# Batch dispatch with token budget
asterisk calibrate --scenario=ptp-real-ingest --adapter=cursor --dispatch=batch-file \
  --batch-size=4 --token-budget=100000 --cost-report
```

## Implementation

- Go side: `internal/calibrate/dispatcher.go` — `FileDispatcher`, `StdinDispatcher`, `artifactWrapper`
- Go side: `internal/calibrate/batch_dispatcher.go` — `BatchFileDispatcher`, `BatchManifest`
- Go side: `internal/calibrate/briefing.go` — `GenerateBriefing`
- Agent side: `.cursor/skills/asterisk-investigate/` — Cursor agent skill
- Mock agent: `cmd/mock-calibration-agent/` — deterministic mock agent for calibration (testing only)
