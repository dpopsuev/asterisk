---
description: Impatient agent — abort blocking operations early, then optimize
alwaysApply: true
---

# Impatient Agent

## Core principle
Time spent waiting on our own code is a design bug, not an inevitable cost. If a command blocks longer than expected, **abort first, analyze second, optimize third**.

## Rules

### 1. Abort-first thresholds
- **Our binaries** (`asterisk`, `mock-calibration-agent`, calibration runs, tests): if no meaningful output for **30 seconds**, kill the process and investigate.
- **External tools** (go build, go test, linters, just recipes): allow up to **60 seconds** for cold builds, **30 seconds** for incremental.
- **Dispatcher polling loops** (file-based or MCP): if a dispatch cycle stalls for more than the configured timeout, do not wait for the full timeout — inspect the dispatcher state, kill, and diagnose.
- When in doubt, **abort sooner** rather than later. A fast feedback loop beats a slow correct one.

### 2. Design for fast abort
When writing or modifying code that involves blocking or long-running operations:
- **Always add a `context.Context` with timeout** — never block indefinitely.
- **Prefer `--timeout` and `--max-stale` flags** over hardcoded waits. If a flag doesn't exist yet, propose adding it.
- **Emit progress signals**: periodic log lines, a heartbeat file, or a progress counter so the agent (and human) can distinguish "working" from "stuck".
- **Fail fast with actionable errors**: "timed out after 10s waiting for signal.json (check dispatcher)" is better than a silent hang.

### 3. Post-abort assessment
After aborting a long-running operation, immediately:
1. **Diagnose**: read the last output, check for deadlocks, infinite loops, or missing exit conditions.
2. **Measure**: if the operation did produce partial output, note how far it got and how long it took.
3. **Propose a fix**: suggest a concrete optimization (parallelism, caching, smaller input, skip redundant work) or a bug fix if the hang was unintentional.
4. **Re-run with instrumentation**: add `--verbose`, timing logs, or profiling flags to the next attempt.

### 4. Calibration-specific
- A full 30-case calibration run should complete in **under 10 minutes** with `--parallel=1`. If it exceeds this, investigate per-step timing.
- Stub calibration (no LLM) should complete in **under 10 seconds**. If it exceeds this, the bottleneck is in our code, not the adapter.
- After each calibration run, note the elapsed time. If it regressed from the previous run, flag it immediately.

## Anti-patterns
- **Waiting and hoping**: sitting through a 5-minute hang without checking output.
- **Retrying without diagnosing**: re-running the same command after a timeout without understanding why it stalled.
- **Unbounded loops**: any `for { ... }` without a `select` on `ctx.Done()` or a max-iteration guard.
- **Silent polling**: `time.Sleep` in a loop with no logging — impossible to distinguish alive from stuck.
