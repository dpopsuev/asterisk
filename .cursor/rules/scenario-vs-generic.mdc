---
description: Always separate scenario-specific from generic; ask before encoding
alwaysApply: true
---

# Scenario vs Generic

When writing or changing docs, rules, or code, **ask:**

**Is this scenario-specific or generic and fits all cases?**

- **Generic** — Applies to any CI run, any operator, any envelope source. No concrete layout, file names, or artifact types; only concepts (timeframe, pipeline, job, failure, job-level artifacts, optional per-failure artifacts). Document in the **pure model** or generic sections; do not hardcode one CI’s layout.
- **Scenario-specific** — Tied to a **current** operator, CI, or use case (e.g. PTP Operator CI, far-edge-vran; current job log format e.g. Ginkgo-style). We do **not** guarantee a specific CI system (e.g. Jenkins) or test framework (e.g. Ginkgo). Layouts, artifact dirs, file names, and output format can change; other operators/CI will differ. Document as **use-case sections** or separate notes; label clearly (e.g. "Current use case: PTP Operator CI").

**Test output format:** BDD is universal; the **output format** (console, CSV, JSON, etc.) can be chosen to improve agent consumption. Which format is better (e.g. CSV vs JSON) may require experiments. See `notes/test-output-and-ci-agnostic.mdc`.

**Rules:**

1. In envelope and artifact docs: keep the **pure model** (hierarchy + artifact concept) generic; put concrete layouts, file names, and meta labels in **current use case** or per-scenario sections.
2. When adding examples or defaults: state whether they are generic or for a specific scenario; if scenario-specific, name the scenario and note that it may change.
3. In code: prefer generic interfaces and data shapes; bind CI/operator-specific layout and naming via configuration or adapters, not as the only supported shape.
