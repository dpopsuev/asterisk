---
description: "Papert Paradigm — low floor, high ceiling, wide walls for framework components"
globs: "pkg/framework/**"
---

# Papert Paradigm

Every framework component must satisfy three properties from Seymour Papert's constructionist design:

| Property | Meaning | Test question |
|----------|---------|---------------|
| **Low floor** | Works with zero configuration | Can a newcomer use this with a single constructor call and no options? |
| **High ceiling** | Supports deep, sophisticated customization | Can an expert replace every policy decision via interfaces or options? |
| **Wide walls** | Enables diverse, unanticipated use cases | Can two developers combine this component in ways the author didn't plan? |

## Checklist

Before merging a new exported type in `pkg/framework/`:

1. **Zero-config constructor exists.** `NewX()` with no required arguments returns a useful, working instance. Sensible defaults everywhere.
2. **Functional options for tuning.** `NewX(opts ...XOption)` pattern. Options are additive — omitting all options gives the low-floor default.
3. **Single-method interfaces.** Prefer `type Vocabulary interface { Name(code string) string }` over multi-method. Single-method interfaces compose via adapters (`VocabularyFunc`, `WalkObserverFunc`) and chains (`ChainVocabulary`, `MultiObserver`).
4. **Adapter functions.** Every single-method interface has a corresponding `XFunc` adapter so plain functions satisfy it without boilerplate.
5. **Composition wrappers.** Multi/Chain types let users combine multiple implementations: `MultiObserver`, `ChainVocabulary`.
6. **No domain imports.** `pkg/framework/` has zero imports from `internal/`. Domains adapt to framework interfaces, not the reverse.
7. **Pass-through default.** When a component transforms input (e.g., code-to-name translation), the default for unknown input is identity (return the input unchanged). Never panic or error on unregistered values.

## Examples

| Component | Low floor | High ceiling | Wide walls |
|-----------|-----------|--------------|------------|
| `MapVocabulary` | Empty registry returns codes as-is | `Register`, `RegisterAll`, `ChainVocabulary` | Wrap `internal/display` via `VocabularyFunc` |
| `NarrationObserver` | `NewNarrationObserver()` logs to slog | Custom `Sink`, `Vocabulary`, milestone interval | Compose with `TraceCollector` via `MultiObserver` |
| `LogObserver` | `&LogObserver{}` uses `slog.Default()` | Inject custom `*slog.Logger` | Combine with `NarrationObserver` in `MultiObserver` |
| `DefaultGraph` | `NewGraph(name, nodes, edges, zones)` | `WithObserver`, `WithDoneNode` options | Attach any `WalkObserver` at graph level |

## Anti-patterns

- **Mandatory configuration.** If the user must provide a non-nil dependency before the type works, the floor is too high.
- **God interface.** If an interface has 5+ methods, implementors pay a tax. Split into single-method interfaces and compose.
- **Sealed defaults.** If the default behavior cannot be overridden without forking, the ceiling is too low. Use interfaces, not concrete types, for all policy decisions.
- **Domain leakage.** If a framework type references `internal/calibrate` or `internal/orchestrate`, it has escaped `pkg/` scope.
