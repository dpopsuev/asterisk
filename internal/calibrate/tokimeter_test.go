package calibrate

import (
	"strings"
	"testing"
	"time"
)

func TestBuildTokiMeterBill_NilTokens(t *testing.T) {
	report := &CalibrationReport{Scenario: "test", Adapter: "stub"}
	bill := BuildTokiMeterBill(report)
	if bill != nil {
		t.Fatal("expected nil bill when Tokens is nil")
	}
}

func TestBuildTokiMeterBill_Basic(t *testing.T) {
	report := &CalibrationReport{
		Scenario: "ptp-real-ingest",
		Adapter:  "cursor",
		CaseResults: []CaseResult{
			{CaseID: "C1", TestName: "TestPTP/sync_loss", Version: "4.16", Job: "e2e"},
			{CaseID: "C2", TestName: "TestPTP/holdover", Version: "4.16", Job: "e2e"},
		},
		Tokens: &TokenSummary{
			TotalPromptTokens:   100_000,
			TotalArtifactTokens: 5_000,
			TotalTokens:         105_000,
			TotalCostUSD:        0.375,
			TotalSteps:          12,
			TotalWallClockMs:    60_000,
			PerCase: map[string]CaseTokenSummary{
				"C1": {PromptTokens: 60000, ArtifactTokens: 3000, TotalTokens: 63000, Steps: 7, WallClockMs: 35000},
				"C2": {PromptTokens: 40000, ArtifactTokens: 2000, TotalTokens: 42000, Steps: 5, WallClockMs: 25000},
			},
			PerStep: map[string]StepTokenSummary{
				"F0_RECALL":      {PromptTokens: 20000, ArtifactTokens: 1000, TotalTokens: 21000, Invocations: 2},
				"F1_TRIAGE":      {PromptTokens: 30000, ArtifactTokens: 2000, TotalTokens: 32000, Invocations: 2},
				"F3_INVESTIGATE": {PromptTokens: 50000, ArtifactTokens: 2000, TotalTokens: 52000, Invocations: 8},
			},
		},
	}

	bill := BuildTokiMeterBill(report)
	if bill == nil {
		t.Fatal("expected non-nil bill")
	}

	if bill.CaseCount != 2 {
		t.Errorf("CaseCount: got %d, want 2", bill.CaseCount)
	}
	if len(bill.CaseLines) != 2 {
		t.Errorf("CaseLines: got %d, want 2", len(bill.CaseLines))
	}
	if len(bill.StepLines) != 3 {
		t.Errorf("StepLines: got %d, want 3", len(bill.StepLines))
	}

	// Verify step ordering follows pipeline order
	if bill.StepLines[0].Step != "F0_RECALL" {
		t.Errorf("first step: got %s, want F0_RECALL", bill.StepLines[0].Step)
	}
	if bill.StepLines[1].Step != "F1_TRIAGE" {
		t.Errorf("second step: got %s, want F1_TRIAGE", bill.StepLines[1].Step)
	}
	if bill.StepLines[2].Step != "F3_INVESTIGATE" {
		t.Errorf("third step: got %s, want F3_INVESTIGATE", bill.StepLines[2].Step)
	}

	// Verify cost calculation for C1
	for _, cl := range bill.CaseLines {
		if cl.CaseID == "C1" {
			expectedCost := float64(60000)/1e6*3.0 + float64(3000)/1e6*15.0
			if cl.CostUSD != expectedCost {
				t.Errorf("C1 cost: got %f, want %f", cl.CostUSD, expectedCost)
			}
		}
	}
}

func TestFormatTokiMeter_Nil(t *testing.T) {
	out := FormatTokiMeter(nil)
	if out != "" {
		t.Errorf("expected empty string for nil bill, got %d bytes", len(out))
	}
}

func TestFormatTokiMeter_Markdown(t *testing.T) {
	report := &CalibrationReport{
		Scenario: "ptp-real-ingest",
		Adapter:  "cursor",
		CaseResults: []CaseResult{
			{CaseID: "C1", TestName: "TestPTP/sync_loss", Version: "4.16", Job: "e2e"},
			{CaseID: "C2", TestName: "TestPTP/holdover_timeout_very_long_name_test", Version: "4.16", Job: "e2e"},
		},
		Tokens: &TokenSummary{
			TotalPromptTokens:   100_000,
			TotalArtifactTokens: 5_000,
			TotalTokens:         105_000,
			TotalCostUSD:        0.375,
			TotalSteps:          12,
			TotalWallClockMs:    90_000,
			PerCase: map[string]CaseTokenSummary{
				"C1": {PromptTokens: 60000, ArtifactTokens: 3000, TotalTokens: 63000, Steps: 7, WallClockMs: 50000},
				"C2": {PromptTokens: 40000, ArtifactTokens: 2000, TotalTokens: 42000, Steps: 5, WallClockMs: 40000},
			},
			PerStep: map[string]StepTokenSummary{
				"F1_TRIAGE": {PromptTokens: 30000, ArtifactTokens: 2000, TotalTokens: 32000, Invocations: 2},
			},
		},
	}

	bill := BuildTokiMeterBill(report)
	md := FormatTokiMeter(bill)

	// Verify markdown structure
	checks := []string{
		"# TokiMeter",
		"## Summary",
		"## Per-case costs",
		"## Per-step costs",
		"| Case |",
		"| Step |",
		"| **TOTAL**",
		"$3/M input",
		"ptp-real-ingest",
		"cursor",
		"C1",
		"C2",
		"Triage (F1)",
		"1m 30s",
		"105.0K",
	}
	for _, check := range checks {
		if !strings.Contains(md, check) {
			t.Errorf("markdown missing: %q", check)
		}
	}

	// Verify it truncates long test names
	if strings.Contains(md, "holdover_timeout_very_long_name_test") {
		t.Error("expected long test name to be truncated")
	}
}

func TestFmtTokens(t *testing.T) {
	tests := []struct {
		n    int
		want string
	}{
		{0, "0"},
		{999, "999"},
		{1000, "1.0K"},
		{1500, "1.5K"},
		{100000, "100.0K"},
		{1234567, "1234.6K"},
	}
	for _, tt := range tests {
		got := fmtTokens(tt.n)
		if got != tt.want {
			t.Errorf("fmtTokens(%d) = %q, want %q", tt.n, got, tt.want)
		}
	}
}

func TestFmtDuration(t *testing.T) {
	tests := []struct {
		ms   int64
		want string
	}{
		{0, "0s"},
		{30000, "30s"},
		{60000, "1m 0s"},
		{89000, "1m 29s"},
		{125000, "2m 5s"},
	}
	for _, tt := range tests {
		d := time.Duration(tt.ms) * time.Millisecond
		got := fmtDuration(d)
		if got != tt.want {
			t.Errorf("fmtDuration(%dms) = %q, want %q", tt.ms, got, tt.want)
		}
	}
}
